CMOS Calculator

Candidate 597618

2014 -- 2015

Abstract

The aim of this project was to build a CMOS simulator, with the 
following interactive elements: 

Abstract

There are many tools in existence to design CMOS circuits, but 
most focus on the physical implementation and the exact 
positioning of gates, rather than a more abstract approach, as 
may be required when reasoning about the layout of circuits, this 
tool seeks to remedy that issue. It quickly became apparent that 
the approach that I was using had various similarities to a 
compiler, which will be a focus of this document. Additionally, 
this report will discuss alternative approaches not used in the 
final implementation to produce the final CMOS output

Table of Contents

    Chapter 1 Introduction
        1.1 Definitions
            1.1.1 Logical Expressions
            1.1.2 CMOS Gates
    Chapter 2 Specification/Requirements
    Chapter 3 Acknowledgements


Introduction

The idea of logical functions is familiar to many, and even a 
schoolchild can grasp the concept of a box receiving true/false 
inputs and producing a true/false output, and lots of these boxes 
in interesting combinations can yield more interesting functions. 
Through introducing these concepts, and producing more and more 
intricate diagrams, a they can then see how more complicated 
ideas, such as addition and subtraction are implemented, and 
maybe how these are used in the modern computers used today. 
However, what is rarely discussed is what is inside these boxes: 
they are usually presented as the lowest level inputs and treated 
as the basic building blocks. The layer underneath this is built 
up of Complementary Metal-Oxide Semiconductors, henceforth 
referred to as CMOS. 

1.1 Definitions

1.1.1 Logical Expressions

A logical expression is built from a combination of constants, 
literals, conjunctions, disjunctions and negations, using a 
grammar described as follows:

e	=	e\land e
	\mid	e\lor e
	\mid	\neg e
	\mid	v
	\mid	c
v	\in	\Sigma
c	=	\top\mid\bot


where \Sigma
 is some accepted alphabet of variable 
(specifically, in this program, as described by the regular 
expression  that is, every alphanumeric phrase, with the 
exception of the single word , which has been reserved for 
specific use within the program). \top\text{ and }\bot
 are used 
within this text to denote the notions true and false, 
respectively. Each variable within the expression that is used is 
given an assignment by an evaluation function, commonly called \mathcal{A}:\mathcal{V}\rightarrow\{\top,\bot\}

, with the set of variables typically denoted as \mathcal{V}
. A 
logical expression E
 is then evaluated recursively based on the 
following rules:

• E=F\land G
: E
 is evaluated as true iff F
 is true and G
 is 
  true (corresponding to ([eq:conj]))

• E=F\lor G
: E
 is evaluated as true iff F
 is true or G
 is 
  true (corresponding to ([eq:disj]))

• E=\neg F
: E
 is evaluated as true iff F
 is false 
  (corresponding to ([eq:neg]))

• E=v
 for some v\in\Sigma
 is evaluated as true iff \mathcal{A}(v)=\top

   (corresponding to ([eq:var]))

• E=c
 for some constant is evaluated as the constant 
  (corresponding to ([eq:con]))

1.1.2 CMOS Gates

As the name would indicate, CMOS is made up of two distinct, 
complementarily defined parts: a P-Gate can only carry high 
potential from their source to their drain, whereas an N-Gate can 
only carry low potential from their drain to their source. Two 
power rails then provide a low potential (the drain), and a high 
potential (the source), with a third wire used as the output 
wire.

P(g,s,d)	=	\neg g\rightarrow(s\leftrightarrow d)
N(g,s,d)	=	g\rightarrow(s\leftrightarrow d)


[eq:pgate] describes a simplified version of the P-Gate: the 
potential is only carried (s\text{ matches }d
) when the input g
 
is not powered, losing the notion that only high potential flows 
from the source to the drain. [eq:ngate] similarly describes a 
simplified version of the N-Gate: the potential is only carried (s\text{ matches }d

) when the input g
 is powered, losing the notion that only low 
potential flows from the drain to the source.

[float Figure:


[Figure 1.1:
N-Gate and P-Gate, respectively
]
]

Therefore, when using these gates, it is not sufficient to 
specify the implementation of a logical expression in a positive 
sense (carrying potential when the valuations of the inputs 
causes the expression to be evaluated as true), but rather, both 
the high potential must be driven to the output, and the low 
potential, using a complementary set of networks, made up solely 
of P-Gates and N-Gates. Throughout this report, and in the 
implementation, these are drawn with the high potential being 
carried from the top of a diagram to the middle by a network of 
P-Gates, and the low potential being carried from the bottom of a 
diagram to the middle by a network of N-Gates. To model 
conjunctions, a pair of P-Gates should be placed in series, 
indicating that the second gate will only carry the potential if 
its variable is not driven, and the first gate is carrying a high 
potential. Similarly, a disjunction is modelled by a pair of 
P-Gates placed in parallel: potential will be carried if at least 
one of the gates' variables is not driven.

In a more general sense, for some expression e
, we want a 
circuit c=(p,n)
 such that p\rightarrow e
 and n\leftarrow e\equiv n\rightarrow\neg e

, where p\text{ and }n
 are entirely made of P- and N- gates 
respectively. 

Suppose that a\land b
 is part of a network of P-Gates, such that 
p
 is the drain immediately above the implementation of a\land b

, and q
 is the source immediately below the implementation. 
Therefore, p
 is acting as the source for a\land b
, and q
 is 
the drain, and we therefore want a series of gates such that a\land b\rightarrow(p\leftrightarrow q)

. As described above, we will need the two gates in series to 
give the necessary result, and they must be connected somehow, so 
we therefore introduce a new variable to act as the point between 
them: a\land b\rightarrow(p\leftrightarrow q)=\exists x\cdot((a\rightarrow(p\leftrightarrow x))\land(b\rightarrow(x\leftrightarrow q)))=\exists x\cdot P(\neg a,p,x)\land P(\neg b,x,q)

. To define a similar construction in N-Gates, we have a\land b\leftarrow p\leftrightarrow q\equiv\neg(a\land b)\rightarrow(p\leftrightarrow q)\equiv\neg a\lor\neg b\rightarrow(p\leftrightarrow q)

, and we therefore derive \neg a\lor\neg b\rightarrow(p\leftrightarrow q)=(\neg a\rightarrow(p\leftrightarrow q))\land(\neg b\rightarrow(p\leftrightarrow q))=N(\neg a,p,q)\land N(\neg b,p,q)


Alternatively, suppose that a\lor b
 is part of a network of 
P-Gates, with p
 and q
 behaving as before, and we therefore want 
a series of gates such that a\lor b\rightarrow(p\leftrightarrow q)

. As described above, we will need the two gates in parallel to 
give the necessary result: a\lor b\rightarrow(p\leftrightarrow q)=(a\rightarrow(p\leftrightarrow q))\land(b\rightarrow(p\leftrightarrow q))=P(\neg a,p,q)\land P(\neg b,p,q)

. To define a similar construction in N-Gates, we have a\lor b\leftarrow p\leftrightarrow q\equiv\neg(a\lor b)\rightarrow(p\leftrightarrow q)\equiv\neg a\land\neg b\rightarrow(p\leftrightarrow q)

, and we therefore derive \neg a\land\neg b\rightarrow(p\leftrightarrow q)=\exists x\cdot(\neg a\rightarrow(p\leftrightarrow x))\land(\neg b\rightarrow(x\leftrightarrow q))=N(\neg a,p,x)\land N(\neg b,p,x)


The following networks are standard implementations of nand- and 
nor-gates:

[float Figure:


[Figure 1.2:
Standard nor- and nand- gate implementations
]
]

Specification/Requirements

The program would be expected to satisfy the following minimal 
requirements in order for it to be considered successful:

• Accuracy: any representation of CMOS produced must correctly 
  implement the logical expression that has been entered, and the 
  visual output of the expression should match the model that has 
  been stored

• Representation: the produced visualisation should be intuitive 
  to read: each element should be presented separately from the 
  others, and clearly labelled. Any gate carrying potential 
  should be clearly highlighted.

• Portability: the visual output produced by the program should 
  be available to the user in a variety of formats

• Interactivity: the program should produce sensible warnings 
  when an expression that is not possible to parse has been 
  entered. Once a CMOS representation has been constructed, it 
  should be possible for the user to interact with the publicly 
  visible inputs (the variables named in the initial expression), 
  with updates delivered with a minimal amount of latency. Should 
  the user wish to view the change in state due to the latency of 
  the gates, this should be visible, and at a variable speed.

Given the nature of the project, the model-view-controller 
paradigm allows a sensible division of labour, also allowing for 
extensibility and clear separation of the purpose of the model 
and the interface.

Acknowledgements

Professor Geraint Jones, my supervisor, for his advice and the 
diagrams of the N-Gates and P-Gates seen in this document.

